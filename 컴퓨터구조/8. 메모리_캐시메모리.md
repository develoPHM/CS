## 캐시 메모리

CPU는 프로그램 실행 과정에서 빈번히 메모리에 접근을 해야함. 하지만 **CPU가 메모리에 접근하는 속도는 CPU가 레지스터에 접근하는 속도보다 느리기 때문에 캐시 메모리에 저장**합니다.

캐시메모리는 CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생한 저장장치.

CPU 와 메모리 사이에 위치한 SRAM 기반의 저장장치입니다.

CPU 코어와 가장 가까운 메모리 순서는 L1 캐시, L2 캐시, L3 캐시순입니다.

메모리 크기는 L1 < L2< L3 순, 속도는 L3 < L2 < L1 순입니다. CPU는 L1 부터 확인하며 메모리를 확인합니다.

## 캐시 히트와 캐시 미스

캐시 메모리는 메모리보다 용량이 작기 때문에 메모리에 있는 모든 내용을 캐시 메모리에 저장할 수는 없습니다. 그렇다면 캐시 메모리에는 무엇을 저장해야 할까..

보조저장장치가 ( 전원이 꺼져도 ) ‘보관할 것’ 을 저장하고, 메모리가 ‘ 실행 중인 것’을 저장한다면 **캐시메모리는 CPU 가 사용할 법**한 것을 저장합니다.

이렇게 캐시 메모리가 예측하여 저장한 데이터가 CPU 에 의해 실제로 사용되는 경우를 **캐시히트**라고 하며, 반대로 예측해서 저장을 했지만 틀린 예측으로 인해 CPU 가 메모리로부터 필요한 데이터를 직접 가져와야 하는 경우를 **캐시 미스** 라고 합니다. 참고로 캐시가 히트되는 비율을 **캐시 적중** 이라고 함.

## 참조 지역성의 원리

캐시 메모리의 이점을 제대로 활용하려면 CPU 가 사용할 법한 데이터를 제대로 예측해서 캐시 적중률을 높여야 합니다. 그렇다면 CPU 가 사용할 법한 데이터는 어떻게 예측할까.

캐시 메모리는 **참조 지역성의 원리**라는 특정한 원칙에 따라 메모리로부터 가져올 데이터를 결정합니다. 참조 지역성의 원리란 CPU 가 메모리에 접근할 때 보이는 주된 경향을 의미함.

- 시간 지역성 : CPU 는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
- 공간 지역성 : CPU 는 접근한 메모리 공간의 근처에 접근하려는 경향이 있다.

## 캐시 메모리의 쓰기 정책과 일관성

이제는 캐시 메모리에 데이터를 쓰는 경우에 대해 알아봅시다. CPU가 캐시 메모리에 데이터를 쓸 때는 캐시 메모리에 새롭게 쓰여진 데이터와 메모리 상의 데이터가 일관성을 유지해야 합니다.

예를 들어 현재 메모리 1000번지에 200이라는 값이 저장되어 있고, 이 값이 캐시 메모리에도 저장되어 있다고 가정해본다. CPU가 이 값에 접근하고자 할 때는 당연히 캐시 메모리를 통해 값을 얻어낼 것입니다. 이때 만약 CPU 가 값 200에서 300으로 바꾸고 싶다면 어떻게 해야할까?

곧장 메모리1000번지로 가서 300으로 바꾸면 이런 일이 일어날 수 있다.

```jsx
명령어 1 : 1000번지 값을 300으로 바꾸기 // 메모리 1000번지의 값 : 300,  캐시메모리 값: 200
명령어 2 : 1000번지 값 출력하기 // 캐시 메모리를 읽어 들일 경우 200 출력
```

이를 방지하기 위해 2가지 방법이 있다.

### 즉시쓰기

캐시메모리와 메모리를 동시에 쓰는 방법.

메모리를 항상 최신 상태로 유지하여 캐시 메모리와 메모리 간의 일관성이 깨지는 상황을 방지할 수 있지만, 데이터를 쓸 때마다 메모리를 참조해야 하므로 시간이 오래 걸림.

### 지연쓰기

캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한 번에 메모리에 반영하는 방법.

즉시쓰기에 비해 속도는 빠르지만 일관성이 깨질 수 있다는 위험을 감수해야 함.